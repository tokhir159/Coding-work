    <!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

    var config = {
        type: Phaser.AUTO,
        width: 1445,
        height: 866,
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    class Player extends Phaser.Physics.Arcade.Sprite
    {
        totalJumps = 2;
        currentJumps = 0;
        playerHP = 100;
        constructor(scene, x, y)
        {
            super(scene, x, y, 'player');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); //We will set gravity *per object* rather than for the scene!
        }
    }
        
    class Enemy extends Phaser.Physics.Arcade.Sprite
    {
        enemyHP = 30;
        constructor(scene, x, y)
        {
            super(scene, x, y, 'enemy')
            //this.animations = enemyAnimations;
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); 
        }

       
    }
        
    class EnemyShooter extends Phaser.Physics.Arcade.Sprite 
    {
        enemyHP = 20;
        hasFired = false;
        constructor(scene, x, y) 
        {
            super(scene, x, y, 'enemy');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000);
            
            
        }
        
        getHasFired ()
        {
            return (this.hasFired)
        }
        
        resetHasFired ()
        {
            this.hasFired = false
        }
        
        enemyFire (x, y)
        {
            var bullet = new Bullet(scene, true)
            this.hasFired = true;
            projectiles.push(bullet)
            bullet.setPosition(x, y);   

            let direction = new Phaser.Math.Vector2(player.x - x, player.y - y);// saving bullet path as vector
            direction.normalize(); // normalize so we can add magnitude
            var speedBullet = 1800;
            bullet.setVelocity(direction.x * speedBullet, direction.y * speedBullet); //moves bullet

            var angle = (Phaser.Math.Angle.Between(x, y, player.x, player.y)*180/(Phaser.Math.PI2/2))
            bullet.setAngle(angle) //rotates bullet sprite
            if (this.hasFired == true)
            {
            scene.time.addEvent({
                callback: ()=>
                {
                    if ((bullet.x > 1445 || bullet.x < 0 || bullet.y > 866 || bullet.y < 0) && (this.hasFired == true))
                    {
                        console.log("WENT OUT OF BOUNDS")
                        bullet.setActive(false)
                        bullet.setVisible(false)
                        bullet.disableBody(true, true)
                        this.hasFired = false;
                    }
                },
                loop: false
            })
            }
            return bullet
        
        }
    }
    
    
    class BatSwing extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene)
        {
            super(scene, 0, 0, 'batSwing');
            scene.add.existing(this)
            scene.physics.add.existing(this)
            projectiles.push(this)
        }

       //swing(x, y) IMPLEMENT LATER ONCE WE HAVE ENEMIES THAT CAN SWING
    }
        

    class Bullet extends Phaser.Physics.Arcade.Sprite
    {
        constructor (scene, enemyBullet)
        {
            super(scene, 0, 0, 'bullet');
            scene.add.existing(this);
            scene.physics.add.existing(this)
            
            var bullets = 0;
            //setCollideWorldBounds(true, true, true, true);
            //scene.physics.world.on('worldbounds', function (body, up, down, left, right) { console.log('object left world bounds'); });
        }
            
        fire (x, y)
        {
   	 
            this.setPosition(x, y);   

            let direction = new Phaser.Math.Vector2(game.input.mousePointer.x - x, game.input.mousePointer.y - y);// saving bullet path as vector
            direction.normalize(); // normalize so we can add magnitude
            var speedBullet = 1800;
            this.setVelocity(direction.x * speedBullet, direction.y * speedBullet); //moves bullet

            var angle = (Phaser.Math.Angle.Between(x, y, game.input.mousePointer.x, game.input.mousePointer.y)*180/(Phaser.Math.PI2/2))
            this.setAngle(angle) //rotates bullet sprite


            // if bullet is out of bounds, despawn
            //DOESN'T WORK CURRENTLY so all bullets stay spawned, but wont' cause any lag
        }
        getBullets ()
        {
            return this.bullets
        }
        
        
    }
        

    var game = new Phaser.Game(config);
    var scene;

    //Game Objects
    var platforms;
    var collisionplatform = [];
    var player;
    var sideEnemy;
    var enemies = [];

    var enemyShooters = [];
    var enemyCount = 12;
        
    var facingRight;


    //Keyboard controls
    var cursors;
    var keys;
        
    var projectileCollider
    
    var dashing = false
        
    
 
    var projectiles = new Array();

    function preload()
    {
        this.load.image('background', 'FIRSTLEVEL.png');
        this.load.image('bullet', 'bullet.png');
        //this.load.atlas('sideEnemy', 'sideEnemy.png', 'sideEnemy.json');
        this.load.image('player', 'assets/wabbit.png');
        this.load.image('enemy', 'assets/wabbit.png');
        this.load.image('platform', 'assets/platform.png');
    }
    
    function create()
    {

       //let Animations = {};
       //var enemyMove = this.anims.create({key: 'enemyMove', frames: this.anims.generateFrameNumbers('enemy', {prefix: 'sideEnemy', start: 1, end: 4, zeroPad: 2}), repeat: -1, frameRate: 10})
       //Animations['enemyMove'] = enemyMove;

        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
       let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'background').setOrigin(0, 0);  
       scene = this;

       //Create the platforms and the player character set to collide with the platforms
       createPlatforms(this);
       player = new Player(this, 400, 400);
        
       this.physics.add.collider(player, platforms);      

       this.physics.world.setBoundsCollision(true, true, true, true); 
        
        
        // Create enemies group
        enemies = this.physics.add.group();
        enemyShooters = this.physics.add.group();

        // Create Enemies

        createEnemies.call(this, 1);
        createEnemyShooters.call(this);
        this.physics.add.collider(enemies);
        this.physics.add.collider(enemyShooters);

       /*this.anims.create({key: 'sideEnemy', frames: this.anims.generateFrameNames('sideEnemy', {prefix: 'sideEnemy', end: 4, zeroPad: 2}), repeat: -1, frameRate: 5});
       let sideEnemy = new EnemyAnimation(this, 700, 300, 'sideEnemy', 'sideEnemy');
       enemies.push(sideEnemy);*/
       //Set up user input
        

       shift = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT)
       shift.on('down', test);
        
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D');
       space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
       space.on('down', jump); //calls jump function when space is pressed
        
        this.input.on('pointerdown', function (pointer)
        {

            const bullet = new Bullet(scene);
            //bullets.push(bullet);
                if (bullet)
                {
                    bullet.fire(player.x, player.y);
                    scene.physics.add.overlap(bullet, collisionplatform, bulletgone, null, scene); 
                    // enemies, etc.
                    scene.physics.add.overlap(bullet, enemies, dealDamageToEnemies, null, scene); 
                    scene.physics.add.overlap(bullet, enemyShooters, dealDamageToEnemies, null, scene); 
                    console.log(projectiles.length);
                }

            }, this);
        
        this.bullets = this.add.group({
            classType: Bullet,
            maxSize: 30,
            runChildUpdate: true
            

        });
        
       projectileCollider = this.physics.add.overlap(player, projectiles, () =>
        {
            player.playerHP -= 10;
            console.log("player hit");
            //Add here what happens to player when attacked, ex. damage animation
        });
        
    /*function createAnims(Animations)
    {
        var enemyMove = this.anims.create({key: 'enemyMove', frames: this.anims.generateFrameNumbers('enemy', {prefix: 'sideEnemy', start: 0, end: 4, zeroPad: 2}), frameRate: 6, repeat: -1})
        Animations['enemyMove'] = enemyMove;
    }*/
       
    }
    function test()
        {
            
            /*let Pdirection = new Phaser.Math.Vector2(8000 - player.x, 1);
            Pdirection.normalize(); 
            var speedP = 2000;
            this.setVelocity(Pdirection.x * speedP, Pdirection.y * speedP); */
            dashing = true;
            var speedP = 1000;
            
            console.log("facing right is "+facingRight)
            console.log("shift pressed")
            
            if (facingRight)
            {
                //player.setVelocity(8000,1)
                let Pdirection = new Phaser.Math.Vector2(8000 - player.x, 1);
                Pdirection.normalize(); 
                player.setVelocity(Pdirection.x * speedP, Pdirection.y * speedP); 
            }
            if (!(facingRight))
            {
                //player.setVelocity(-8000,1)
                let Pdirection = new Phaser.Math.Vector2(-8000 - player.x, 1);
                Pdirection.normalize(); 
                player.setVelocity(Pdirection.x * speedP, Pdirection.y * speedP); 
            }
            
                projectileCollider.active = false;
                console.log("collision is off")
                scene.time.delayedCall(300, () =>
                {   
                    projectileCollider.active = true;
                    console.log("collision is back on")
                    dashing = false;
                });
        }
    function createPlatforms(scene)
    {
        platforms = scene.physics.add.staticGroup();

        //basePlatform is the floor of the game
        let basePlatform = platforms.create(0, game.scale.height, 'platform');
        basePlatform.setScale(1000, 1).refreshBody(); //scales the base platform in the x axis to cover the entire floor
        
        let newPlatform = platforms.create(1000, 650, 'platform')
        collisionplatform.push(newPlatform)
        console.log(collisionplatform)

        
    }

    function update()
    {
        
        
        //Player will not move in the x-axis unless a movement key is being pressed
        if (!(dashing))
        player.setVelocityX(5);

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(2000);

        //Handle player movements
        if ((cursors.left.isDown || keys.A.isDown) && (!(dashing)))
        {
            player.setVelocityX(-325);
            facingRight = false;
        }

        if ((cursors.right.isDown || keys.D.isDown) && (!(dashing)))
        {
            player.setVelocityX(325);
            facingRight = true;
        }
        
        if (player.body.touching.down) 
        {
            player.currentJumps = 0;
        }
        
        // Enemy follow player
        enemies.children.iterate(function (enemy) 
        {
            if (enemy.body.touching.down) 
            {
                if(Math.abs(enemy.x - player.x) <= 200 && Math.abs(enemy.y - player.y) <= 200)
                {
                    if (player.x < enemy.x)                    {
                        enemy.setVelocityX(-100);
                        //enemy.play(enemy.animations['enemyMove'], true)
                    } 
                    else if (player.x > enemy.x) 
                    {
                        enemy.setVelocityX(100);
                        
                        //enemy.play(enemy.animations['enemyMove'], true)
                    }
                }
                else
                {
                    enemy.setVelocityX(0);
                }
            }
        });
        

       enemyShooters.children.iterate(function (enemyShooter) 
        {
            if(Math.abs(enemyShooter.y - player.y) <= 100 && Math.abs(enemyShooter.x - player.x) <= 500)
            {
                
                //bullets.push(bullet); 
                console.log(enemyShooter.getHasFired())
                if (!(enemyShooter.getHasFired()))
                {
                    console.log('enemy has not shot yet')
                    enemyBullet = enemyShooter.enemyFire(enemyShooter.x, enemyShooter.y)
                    
                    scene.time.addEvent
                    ({delay:1000,
                    callback: ()=>
                    {
                            console.log("reset fire")
                            enemyShooter.resetHasFired();
                    },
                    loop: false
                    })
                        
                    
                }
                    //scene.physics.add.overlap(enemyBullet, player, bulletgone, null, scene); 
                    //scene.physics.add.overlap(enemyBullet, collisionplatform, bulletgone, null, scene); 
                
                // enemies, etc.
                
            }
        })
        
        // EnemyShooters shoot when player is in FOV
        
        //check in update function when an enemy is defeated 
        //checkIfAllEnemiesAreDead.call();
        //
        //!!!Add bullet disappear function here. Use bullets.children.iterate
        /*if (bullet.x > 1445 || bullet.x < 0 || bullet.y < 0 || bullet.y > 866)
        {
            console.log("hits bounds");
            this.disableBody(true, true);
        }*/
        
        //live separation to make enemies not stack
        
    }
    function bulletgone(bullet, platform)
    {
        bullet.disableBody(true,true);
        console.log("bullet hit")
    }
    function jump(event)
    {
        if (player.body.touching.down) 
        {
            // If the player is on the ground, the player can jump
            player.setVelocityY(-1100);
            player.currentJumps++;
        } 
        else if (player.currentJumps < player.totalJumps) 
        {
            // If the player is not on the ground but has an available air jump, use that jump
            player.setVelocityY(-800);
            player.currentJumps++;
        }
    }
    
    function createEnemies(number) 
    {
        // Create Enemy
        for (let i = 0; i < number; i++) 
        {
            let enemy = new Enemy(scene, Phaser.Math.Between(100, 1100), Phaser.Math.Between(100, 600), 'enemy', 'sideEnemy');
            enemies.add(enemy);

            // Collide enemies with platforms
            scene.physics.add.collider(enemy, platforms);
            enemy.setGravityY(3000);
            enemy.setPushable(true);
            //enemy.setBounce(1);
        }

    }
        
    function createEnemyShooters() 
    {
        // Create Enemy
        
        let enemyShooter1 = new EnemyShooter(scene, 1200, 300);
        enemyShooters.add(enemyShooter1);
        scene.physics.add.collider(enemyShooter1, platforms);
        enemyShooter1.setGravityY(3000);
        enemyShooter1.setPushable(true);
        //let enemyShooter2 = new EnemyShooter(scene, 1100, 300);
        //enemyShooters.add(enemyShooter2);
        //scene.physics.add.collider(enemyShooter2, platforms);
        //enemyShooter2.setGravityY(3000);
        //enemyShooter2.setPushable(true);
    }
        
    function dealDamageToEnemies(bullet, enemy)
    {
        bullet.disableBody(true,true);
        console.log("enemy damaged");
        enemy.enemyHP -= 10;
        if(enemy.enemyHP <= 0)
        {
            enemy.disableBody(true,true);
            enemyCount--;
            //remove enemy from enemyShooters group
            enemyShooters.remove(enemy, true, true);
            console.log("enemy defeated");
            if(enemyCount == 0)
            {
                console.log("All enemies defeated");
                switchStage.call();
            }
        }
    }
    
    function switchStage()
    {
        
    }
    /*class EnemyAnimation extends Enemy
    {
        constructor(scene, x, y, spritesheet, animation) 
        {
            super(scene, x, y, spritesheet, animation);
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(0.8);
            this.play(animation);
        }

        addTween(scene, xDist, yDist, time) 
        {
            scene.tweens.add({ targets: this, x: xDist, y: yDist, duration: time, ease: 'Sine.easeInOut', repeat: -1, yoyo: true });
        }
    }*/
    

    </script>

</body>

</html>
